  /*
      Oliver Lynch
      Project 5
      1 December 2020
  */

// bison syntax indicating C++ declarations required by both the parser and scanner
%code requires {
  class Expression;
  class Variable;
  struct Parameter;
  class Statement;
  #ifndef P1
    #include "gpl_type.h"  //include in all projects except the first
  #endif
  #ifdef GRAPHICS
    #include "Window.h"
  #endif
  #include <string>

}

// bison syntax to indicate the beginning of a C/C++ code section
%{

extern int yylex();  // prototype of function generated by flex
extern int yyerror(const char *); // used to print errors
extern int line_count;            // current line in the input; from record.l

#include "error.h"      // class for printing errors (used by gpl)
#include "gpl_type.h"
#include "Table_handler.h"
#include "Constant.h"
#include "Expression.h"
#include "Variable.h"
#include "gpl.tab.h"
#include "Symbol.h"
#include "Game_object.h"
#include "statement.h"
#include "Window.h"
#include "Event_manager.h"
#include "Locator.h"
#include "Animation_code.h"
#include <algorithm>

#include <iostream>

struct Parameter {
      Expression* expression;
      std::string name;
      Parameter* next;
      ~Parameter() { delete next; }
};


template<typename BINOP, Operator_type NM>
Expression* Bin_op_check(Expression* one, Expression* three, unsigned int valid_types){
    unsigned int lh_valid = one->type() & valid_types;
    unsigned int rh_valid = three->type() & valid_types;
    if(!lh_valid){
        Error::error(Error::INVALID_LEFT_OPERAND_TYPE, operator_to_string(NM));
    }
    if(!rh_valid){
        Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, operator_to_string(NM));
    }

    if(lh_valid && rh_valid){
        return new BINOP(one, three);
    }else{
        delete one;
        delete three;
        return new Integer_constant(0);
    }
}

template<typename UNOP, Operator_type NM>
Expression* Un_op_check(Expression* arg, unsigned int valid_types){
    unsigned int op_valid = arg->type() & valid_types;
    if(!op_valid){
        Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, operator_to_string(NM));
        delete arg;
        return new Integer_constant(0);
    }else{
        return new UNOP(arg);
    }
}

// bison syntax indicating the end of a C/C++ code section
%} 


// turn on verbose (longer) error messages
%define parse.error verbose

%union {
 int                union_int;
 double             union_double;
 std::string*       union_string;  // MUST be a pointer to a string
 Gpl_type           union_gpl_type;
 Expression*        union_expression_ptr;
 Variable*	        union_variable_ptr;
 Parameter*         union_parameter_ptr;
 Statement*         union_statement_ptr;
 Window::Keystroke  union_keystroke_ptr;
};

%destructor {delete $$;} <union_string> //release scanner mem

// tokens declared here
 /* updated January 2019 
  * Copy the following token declarations into your .y file. */

 /* Tokens with angle braces < > after %token require a type. 
  * This is the type of the variable the scanner (flex) puts into the union.
  * Fill in the < > with the appropriate union variable
  *     for example
  *     %token <union_int> T_INT_CONSTANT       "int constant" 
  */

%token T_INT                 "int"
%token T_DOUBLE              "double"
%token T_STRING              "string"
%token T_TRIANGLE            "triangle"
%token T_PIXMAP              "pixmap"
%token T_CIRCLE              "circle"
%token T_RECTANGLE           "rectangle"
%token T_TEXTBOX             "textbox"

%token <union_int> T_FORWARD         "forward"  /* value is line number */
%token T_INITIALIZATION      "initialization"
%token T_TERMINATION         "termination"
%token T_ON                  "on"
%token T_ANIMATION           "animation"
%token T_IF                  "if"
%token IF_NO_ELSE            "if without an else"
%token T_FOR                 "for"
%token T_ELSE                "else"
%token <union_int> T_EXIT            "exit"  /* value is line number */
%token <union_int> T_PRINT           "print"  /* value is line number */
%token T_TRUE                "true"
%token T_FALSE               "false"

%token T_SPACE               "space"
%token T_LEFTARROW           "leftarrow"
%token T_RIGHTARROW          "rightarrow"
%token T_UPARROW             "uparrow"
%token T_DOWNARROW           "downarrow"
%token T_LEFTMOUSE_DOWN      "leftmouse_down"
%token T_MIDDLEMOUSE_DOWN    "middlemouse_down"
%token T_RIGHTMOUSE_DOWN     "rightmouse_down"
%token T_LEFTMOUSE_UP        "leftmouse_up"
%token T_MIDDLEMOUSE_UP      "middlemouse_up"
%token T_RIGHTMOUSE_UP       "rightmouse_up"
%token T_MOUSE_MOVE          "mouse_move"
%token T_MOUSE_DRAG          "mouse_drag"
%token T_F1                  "f1"
%token T_AKEY                "akey"
%token T_SKEY                "skey"
%token T_DKEY                "dkey"
%token T_FKEY                "fkey"
%token T_HKEY                "hkey"
%token T_JKEY                "jkey"
%token T_KKEY                "kkey"
%token T_LKEY                "lkey"
%token T_WKEY                "wkey"
%token T_ZKEY                "zkey"

%token T_LPAREN              "("
%token T_RPAREN              ")"
%token T_LBRACE              "{"
%token T_RBRACE              "}"
%token T_LBRACKET            "["
%token T_RBRACKET            "]"
%token T_SEMIC               ";"
%token T_COMMA               ","
%token T_PERIOD              "."

%token T_ASSIGN              "="
%token T_PLUS_ASSIGN         "+="
%token T_MINUS_ASSIGN        "-="
%token T_PLUS_PLUS           "++"
%token T_MINUS_MINUS         "--"

%token T_SIN                 "sin"
%token T_COS                 "cos"
%token T_TAN                 "tan"
%token T_ASIN                "asin"
%token T_ACOS                "acos"
%token T_ATAN                "atan"
%token T_SQRT                "sqrt"
%token T_ABS                 "abs"
%token T_FLOOR               "floor"
%token T_RANDOM              "random"

%token T_TOUCHES             "touches"
%token T_NEAR                "near"

%token T_MULTIPLY            "*"
%token T_DIVIDE              "/"
%token T_PLUS                "+"
%token T_MINUS               "-"
%token T_MOD                 "%"

%token T_LESS                "<"
%token T_GREATER             ">"
%token T_LESS_EQUAL          "<="
%token T_GREATER_EQUAL       ">="
%token T_EQUAL               "=="
%token T_NOT_EQUAL           "!="
%token T_NOT                 "!"
%token T_AND                 "&&"
%token T_OR                  "||"
%token T_NEWLINE             "\n or \r"

/* Complex tokens */
%token T_CONSTANT
%token T_DBLCONSTANT
%token T_STRCONSTANT
%token T_IDENTIFIER
%token T_COMMENT


%token <union_int>    T_INT_CONSTANT    "int constant"
%token <union_double> T_DOUBLE_CONSTANT "double constant"
%token <union_string> T_STRING_CONSTANT "string constant"
%token <union_string> T_ID            	 "identifier"

 /* special token that does not match any production */
 /* used for characters that are not part of the language */
%token T_ERROR               "error"

%type <union_string>         animation_declaration
%type <union_gpl_type>       simple_type
%type <union_gpl_type>       object_type
%type <union_gpl_type>       animation_parameter;
%type <union_expression_ptr> primary_expression
%type <union_expression_ptr> expression
%type <union_expression_ptr> optional_initializer
%type <union_variable_ptr>   variable
%type <union_parameter_ptr>  parameter
%type <union_parameter_ptr>  parameter_list
%type <union_parameter_ptr>  parameter_list_or_empty
%type <union_statement_ptr>  statement
%type <union_statement_ptr>  print_statement
%type <union_statement_ptr>  statement_list
%type <union_statement_ptr>  statement_block
%type <union_statement_ptr>  assign_statement
%type <union_statement_ptr>  assign_statement_or_empty
%type <union_statement_ptr>  statement_or_block_of_statements
%type <union_statement_ptr>  if_statement
%type <union_statement_ptr>  exit_statement
%type <union_statement_ptr>  for_statement
%type <union_keystroke_ptr>  keystroke


%left T_OR
%left T_AND
%left T_EQUAL T_NOT_EQUAL
%left T_GREATER T_LESS T_GREATER_EQUAL T_LESS_EQUAL  
%left T_PLUS T_MINUS
%left T_MULTIPLY T_DIVIDE T_MOD
%nonassoc T_NOT
%nonassoc UNARY_OPS
%nonassoc T_NEAR T_TOUCHES
%nonassoc IF_NO_ELSE
%nonassoc T_ELSE


%%
//---------------------------------------------------------------------
program:
    declaration_list block_list{
        std::set<std::string>  declared = Animation_code::declared_blocklist;
        std::set<std::string>  defined = Animation_code::defined_blocklist;
        std::set<std::string>  diff;
        std::set<std::string>  used = Animation_code::used_blocklist;
        std::set<std::string>  errorDiff;


        std::set_difference(declared.begin(), declared.end(), 
            defined.begin(), defined.end(), std::inserter(diff, diff.begin()));
    
        Table_handler& myhandler = Table_handler::instance();
        for(auto x : diff){
            myhandler.erase(x);
        }

        std::set_difference(used.begin(), used.end(), defined.begin(), 
            defined.end(), std::inserter(errorDiff, errorDiff.begin()));

        for(auto i : errorDiff) {
            Error::error(Error::NO_BODY_PROVIDED_FOR_FORWARD, i);
        } 
    }
    ;

//---------------------------------------------------------------------
declaration_list:
    declaration_list declaration
    | empty
    ;

//---------------------------------------------------------------------
declaration:
    variable_declaration T_SEMIC
    | object_declaration T_SEMIC
    | forward_declaration T_SEMIC
    ;

//---------------------------------------------------------------------
variable_declaration:
    simple_type  T_ID  optional_initializer{ //$1 , $2, $3
        Table_handler& myhandler = Table_handler::instance();

        //if defined error, else insert a new symbol
        if(myhandler.defined_in_current_scope(*$2)){ 
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
            delete $2;
            break;
        }else{
            string tmp = gpl_type_to_string($1);
            try{
                if(tmp == "double"){
                    if($3 == nullptr){
                        myhandler.insert(std::make_shared<Symbol>(*$2, new double(0.0)));
                    }else{
                        myhandler.insert(std::make_shared<Symbol>(*$2, new double($3->evaluate()->as_double())));
                    }
                }else if(tmp == "int"){
                    if($3 == nullptr){
                        myhandler.insert(std::make_shared<Symbol>(*$2, new int(0)));
                    }else{
                        myhandler.insert(std::make_shared<Symbol>(*$2, new int($3->evaluate()->as_int())));
                    }
                }else if(tmp == "string"){
                    if($3 == nullptr){
                        myhandler.insert(std::make_shared<Symbol>(*$2, new string("")));
                    }else{
                        myhandler.insert(std::make_shared<Symbol>(*$2, new string($3->evaluate()->as_string())));
                    }
                }
            }catch(Gpl_type unexpected_type){
                Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE, gpl_type_to_string(unexpected_type), *$2, gpl_type_to_string($1));
                if(tmp == "double"){
                    myhandler.insert(std::make_shared<Symbol>(*$2, new double(0.0)));
                }else if(tmp == "int"){
                    myhandler.insert(std::make_shared<Symbol>(*$2, new int(0)));
                }else if(tmp == "string"){
                    myhandler.insert(std::make_shared<Symbol>(*$2, new string));
                }
            }
        }
        delete $2; //free the mem
        delete $3; //free the mem
    }
    | simple_type  T_ID T_LBRACKET expression T_RBRACKET{ // $1 $2 $3 $4
        Table_handler& myhandler = Table_handler::instance();
        int size = 1;
        auto myfour = $4->evaluate();
        Gpl_type mytype = myfour->type();

        if(mytype != INT){
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, gpl_type_to_string(myfour->type()), *$2);
        }else{
            size = myfour->as_int();
            if(size < 1){
                Error::error(Error::INVALID_ARRAY_SIZE, *$2, std::to_string(size));
                size = 1;
            }
        }

        if(myhandler.defined_in_current_scope(*$2)){
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
        }else{
            string tmp = gpl_type_to_string($1);
            if(tmp == "double"){ 
                double* mydbl = new double[size]();
                for(int i = 0; i < size; i++){ //array looper
                    mydbl[i] = 0;
                }
                myhandler.insert(std::make_shared<Symbol>(*$2, mydbl, size));
            }if(tmp == "int"){
                int* myint = new int[size]();
                for(int i = 0; i < size; i++){ //array looper
                    myint[i] = 0;
                }
                myhandler.insert(std::make_shared<Symbol>(*$2, myint, size));
            }if(tmp == "string"){
                string* mystr = new string[size]();
                for(int i = 0; i < size; i++) { //array looper
                    mystr[i] = string("");
                }
                myhandler.insert(std::make_shared<Symbol>(*$2, mystr, size));
            }
        }
        delete $2; //free mem
        delete $4; //free mem
    }
    ;

//---------------------------------------------------------------------
simple_type:
    T_INT      {$$=INT;}
    | T_DOUBLE {$$=DOUBLE;}
    | T_STRING {$$=STRING;}
    ;

//---------------------------------------------------------------------
optional_initializer:
    T_ASSIGN expression {$$ = $2;}
    | empty             {$$ = nullptr;}
    ;

//---------------------------------------------------------------------
object_declaration:
    object_type T_ID parameter_list_or_empty{
        Table_handler& myhandler = Table_handler::instance();
        string tmp = gpl_type_to_string($1);
        Game_object* gop;
        Parameter* myp = $3;

        if(myhandler.defined_in_current_scope(*$2)){ 
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
            delete $2;
            break;
        }else{
            if(tmp == "rectangle"){
                Rectangle* ptr = new Rectangle;
                myhandler.insert(std::make_shared<Symbol>(*$2, ptr));
                gop = ptr;
            }else if(tmp == "circle"){
                Circle* ptr = new Circle;
                myhandler.insert(std::make_shared<Symbol>(*$2, ptr));
                gop = ptr;
            }else if(tmp == "triangle"){
                Triangle* ptr = new Triangle;
                myhandler.insert(std::make_shared<Symbol>(*$2, ptr));
                gop = ptr;
            }else if(tmp == "pixmap"){
                Pixmap* ptr = new Pixmap;
                myhandler.insert(std::make_shared<Symbol>(*$2, ptr));
                gop = ptr;
            }else if(tmp == "textbox"){
                Textbox* ptr = new Textbox;
                myhandler.insert(std::make_shared<Symbol>(*$2, ptr));
                gop = ptr;
            }
            while(myp != nullptr) {
                try{
                    tmp = gpl_type_to_string(gop->attribute_type(myp->name));
                    if(tmp == "int"){
                        gop->write_attribute(myp->name, myp->expression->evaluate()->as_int());
                    }else if(tmp == "double"){
                        gop->write_attribute(myp->name, myp->expression->evaluate()->as_double());
                    }else if(tmp == "string"){
                        gop->write_attribute(myp->name, myp->expression->evaluate()->as_string());
                    }else if(tmp == "animation_block"){
                        const Animation_code* AC = myp->expression->evaluate()->as_animation_block();
                        gop->write_attribute(myp->name, AC);
                        Animation_code::used_blocklist.insert(AC->get_block_name());
                    }
                }catch(Gpl_type err){
                    Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, myp->name);
                }catch(std::out_of_range& err){
                    Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, gpl_type_to_string($1), myp->name);
                }
                myp = myp->next;
            }
        }
        delete $2;
    } 
    | object_type T_ID T_LBRACKET expression T_RBRACKET{
        Table_handler& myhandler = Table_handler::instance();
        int size = 1;
        auto myfour = $4->evaluate();
        Gpl_type mytype = myfour->type();

        if(mytype != INT){
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, gpl_type_to_string(myfour->type()), *$2);
        }else{
            size = myfour->as_int();
            if(size < 1){
                Error::error(Error::INVALID_ARRAY_SIZE, *$2, std::to_string(size));
                size = 1;
            }
        }

        if(myhandler.defined_in_current_scope(*$2)){
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
        }else{
            string tmp = gpl_type_to_string($1);
            if(tmp == "rectangle"){ 
                Rectangle* myrectangle = new Rectangle[size];
                myhandler.insert(std::make_shared<Symbol>(*$2, myrectangle, size));
            }if(tmp == "circle"){
                Circle* mycircle = new Circle[size]();
                myhandler.insert(std::make_shared<Symbol>(*$2, mycircle, size));
            }if(tmp == "triangle"){
                Triangle* mytriangle = new Triangle[size];
                myhandler.insert(std::make_shared<Symbol>(*$2, mytriangle, size));
            }if(tmp == "pixmap"){
                Pixmap* mypixmap = new Pixmap[size];
                myhandler.insert(std::make_shared<Symbol>(*$2, mypixmap, size));
            }if(tmp == "textbox"){
                Textbox* mytextbox = new Textbox[size];
                myhandler.insert(std::make_shared<Symbol>(*$2, mytextbox, size));
            }
        }
        delete $2; //free mem
        delete $4; //free mem
    } 
    ;

//---------------------------------------------------------------------
object_type:
    T_TRIANGLE    {$$ = TRIANGLE;}
    | T_PIXMAP    {$$ = PIXMAP;}
    | T_CIRCLE    {$$ = CIRCLE;}
    | T_RECTANGLE {$$ = RECTANGLE;}
    | T_TEXTBOX   {$$ = TEXTBOX;}
    ;

//---------------------------------------------------------------------
parameter_list_or_empty:
    T_LPAREN parameter_list T_RPAREN {$$ = $2;}
    | T_LPAREN empty T_RPAREN        {$$ = nullptr;}
    | empty                          {$$ = nullptr;}
    ;

//---------------------------------------------------------------------
parameter_list:
    parameter_list T_COMMA parameter{
        auto ptr = $1;
        while(ptr->next != nullptr){
            ptr = ptr->next;
        }
        ptr->next = $3;
        $$ = $1;
    }
    | parameter {$$ = $1;}
    ;

//---------------------------------------------------------------------
parameter:
    T_ID T_ASSIGN expression {
        $$ = new Parameter;
        $$->expression = $3;
        $$->name = *$1;
        $$->next = nullptr;
        delete $1;
    }
    ;

//---------------------------------------------------------------------
block_list:
    block_list block
    | empty
    ;

//---------------------------------------------------------------------
block:
    initialization_block
    | termination_block
    | animation_block
    | on_block
    ;

//---------------------------------------------------------------------
initialization_block:
    T_INITIALIZATION statement_block{
        Event_manager &myEvent = Event_manager::instance();
        myEvent.add_handler(Window::INITIALIZE, $2); 
    }
    ;

//---------------------------------------------------------------------
termination_block:
    T_TERMINATION statement_block{
        Event_manager &myEvent = Event_manager::instance();
        myEvent.add_handler(Window::TERMINATE, $2); 
    }
    ;

//---------------------------------------------------------------------
forward_declaration:
    T_FORWARD T_ANIMATION T_ID T_LPAREN animation_parameter T_RPAREN{
        Table_handler& myhandler = Table_handler::instance();
        if(myhandler.defined_in_current_scope(*$3)){
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$3);
        }else{
            Animation_code *ac = new Animation_code(*$3, $5);
            myhandler.insert(std::make_shared<Symbol>(*$3, ac));
            Animation_code::declared_blocklist.insert(*$3);
        }
    } 
    ;

//---------------------------------------------------------------------
animation_parameter:
    object_type T_ID    {$$ = $1; $2;} 
    | object_type       {$$ = $1;}
    ;

//---------------------------------------------------------------------
animation_block:
    animation_declaration statement_block{
        Table_handler& myhandler = Table_handler::instance();
        myhandler.pop_table();
        if($1){
            auto mySym = myhandler.lookup(*$1);
            mySym->as_lvalue()->mutate($2);
            Animation_code::defined_blocklist.insert(*$1);
        }
    }
    ;

//---------------------------------------------------------------------
animation_declaration:
    T_ANIMATION T_ID T_LPAREN object_type T_ID T_RPAREN{
        Table_handler& myhandler = Table_handler::instance();
        auto sym = myhandler.lookup(*$2);
        if(!sym){
            myhandler.insert(sym=std::make_shared<Symbol>(*$2, new Animation_code(*$2, $4)));
        }
        if(sym->get_type() == ANIMATION_CODE){
            std::shared_ptr<const Constant> AC {sym->as_constant()};
            Gpl_type myType = AC->as_animation_block()->get_parameter_type();
            if($4 == myType){
                sym->as_lvalue()->mutate(*$5);
                $$ = $2;
            }else{
                Error::error(Error::ANIMATION_PARAM_DOES_NOT_MATCH_FORWARD, gpl_type_to_string($4), gpl_type_to_string(myType));
            }
        }else{
            Error::error(Error::REDECLARATION_OF_SYMBOL_AS_ANIMATION_BLOCK, *$2);
            $$ = nullptr;
        }
        
        myhandler.push_table();

        string tmp = gpl_type_to_string($4);

        if(tmp == "rectangle"){
            Rectangle* ptr = new Rectangle;
            myhandler.insert(std::make_shared<Symbol>(*$5, ptr));
        }else if(tmp == "circle"){
            Circle* ptr = new Circle;
            myhandler.insert(std::make_shared<Symbol>(*$5, ptr));
        }else if(tmp == "triangle"){
            Triangle* ptr = new Triangle;
            myhandler.insert(std::make_shared<Symbol>(*$5, ptr));
        }else if(tmp == "pixmap"){
            Pixmap* ptr = new Pixmap;
            myhandler.insert(std::make_shared<Symbol>(*$5, ptr));
        }else if(tmp == "textbox"){
            Textbox* ptr = new Textbox;
            myhandler.insert(std::make_shared<Symbol>(*$5, ptr));
        }
    }
    ;

//---------------------------------------------------------------------
on_block:
    T_ON keystroke statement_block {
        Event_manager &myhandler = Event_manager::instance(); 
        myhandler.add_handler($2, $3);
    }
    ;

//---------------------------------------------------------------------
keystroke:
    T_SPACE              {$$=Window::SPACE;}
    | T_UPARROW          {$$=Window::UPARROW;}
    | T_DOWNARROW        {$$=Window::DOWNARROW;}
    | T_LEFTARROW        {$$=Window::LEFTARROW;}
    | T_RIGHTARROW       {$$=Window::RIGHTARROW;}
    | T_LEFTMOUSE_DOWN   {$$=Window::LEFTMOUSE_DOWN;}
    | T_MIDDLEMOUSE_DOWN {$$=Window::MIDDLEMOUSE_DOWN;}
    | T_RIGHTMOUSE_DOWN  {$$=Window::RIGHTMOUSE_DOWN;}
    | T_LEFTMOUSE_UP     {$$=Window::LEFTMOUSE_UP;}
    | T_MIDDLEMOUSE_UP   {$$=Window::MIDDLEMOUSE_UP;}
    | T_RIGHTMOUSE_UP    {$$=Window::RIGHTMOUSE_UP;}
    | T_MOUSE_MOVE       {$$=Window::MOUSE_MOVE;}
    | T_MOUSE_DRAG       {$$=Window::MOUSE_DRAG;}
    | T_AKEY             {$$=Window::AKEY;}
    | T_SKEY             {$$=Window::SKEY;}
    | T_DKEY             {$$=Window::DKEY;}
    | T_FKEY             {$$=Window::FKEY;}
    | T_HKEY             {$$=Window::HKEY;}
    | T_JKEY             {$$=Window::JKEY;}
    | T_KKEY             {$$=Window::KKEY;}
    | T_LKEY             {$$=Window::LKEY;}
    | T_WKEY             {$$=Window::WKEY;}
    | T_ZKEY             {$$=Window::ZKEY;}
    | T_F1               {$$=Window::F1;}
    ;

//---------------------------------------------------------------------
statement_or_block_of_statements:
    statement_block
    | statement
    ;

//---------------------------------------------------------------------
statement_block:
    T_LBRACE statement_list T_RBRACE {$$=$2;} 
    | T_LBRACE T_RBRACE              {$$=new NullStatement;}
    ;


//---------------------------------------------------------------------
statement_list:
    statement_list statement {$1->append_statement($2); $$=$1;}
    | statement 
    ;

//---------------------------------------------------------------------
statement:
    if_statement               {$$ = $1;}
    | for_statement            {$$ = $1;}
    | assign_statement T_SEMIC {$$ = $1;}
    | print_statement T_SEMIC  {$$ = $1;}
    | exit_statement T_SEMIC   {$$ = $1;}
    ;

//---------------------------------------------------------------------
if_statement:
    T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements %prec IF_NO_ELSE{
        if($3->type() != INT){
            Error::error(Error::INVALID_TYPE_FOR_IF_STMT_EXPRESSION);
        }else{
            $$=new If($3, $5);
        }
    }
    | T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements T_ELSE statement_or_block_of_statements{
        if($3->type() != INT) {
            Error::error(Error::INVALID_TYPE_FOR_IF_STMT_EXPRESSION);
        }else{
            $$=new If($3, $5, $7);
        }
    }
    ;

//---------------------------------------------------------------------
for_statement:
    T_FOR T_LPAREN assign_statement_or_empty T_SEMIC expression T_SEMIC assign_statement_or_empty T_RPAREN statement_or_block_of_statements{
        if($5->type() != INT){
            Error::error(Error::INVALID_TYPE_FOR_FOR_STMT_EXPRESSION);
        }else{
            $$=new For($3, $5, $7, $9);
        }
    }
    ;

//---------------------------------------------------------------------
print_statement:
    T_PRINT T_LPAREN expression T_RPAREN {
        bool valid_string = $3->type() & (INT|DOUBLE|STRING);
        if(!valid_string){
            Error::error(Error::INVALID_TYPE_FOR_PRINT_STMT_EXPRESSION);
        }else{
            $$ = new Print($1, $3);
        }
    }
    ;

//---------------------------------------------------------------------
exit_statement: 
    T_EXIT T_LPAREN expression T_RPAREN{
        if($3->type() != INT){
            Error::error(Error::EXIT_STATUS_MUST_BE_AN_INTEGER, gpl_type_to_string($3->type()));
            break;
        }else{
            $$ = new Exit($1, $3);
        }
    }
    ;

//---------------------------------------------------------------------
assign_statement_or_empty:
    assign_statement    {$$ = $1;}
    | empty             {$$ = new NullStatement;}
    ;

//---------------------------------------------------------------------
assign_statement:
    variable T_ASSIGN expression {
        Gpl_type mytype = $1->type();
        if(!(mytype & (INT|DOUBLE|STRING|ANIMATION_BLOCK))){
            Error::error(Error::INVALID_LHS_OF_ASSIGNMENT,
                 $1->get_name(), gpl_type_to_string(mytype));
            $$ = new NullStatement;
        }else if(mytype == DOUBLE && !($3->type() & (DOUBLE|INT))){
            Error::error(Error::ASSIGNMENT_TYPE_ERROR,
                 gpl_type_to_string(mytype), gpl_type_to_string($3->type()));
            $$ = new NullStatement;
        }else if(mytype == STRING && !($3->type() & (DOUBLE|INT|STRING))){
            Error::error(Error::ASSIGNMENT_TYPE_ERROR,
                 gpl_type_to_string(mytype), gpl_type_to_string($3->type()));
            $$ = new NullStatement;
        }else if(mytype == INT && mytype != $3->type()){
            Error::error(Error::ASSIGNMENT_TYPE_ERROR,
                gpl_type_to_string(mytype), gpl_type_to_string($3->type()));
            $$ = new NullStatement;
        }else if(mytype == ANIMATION_CODE){
            Error::error(Error::CANNOT_ASSIGN_TO_ANIMATION_CODE, gpl_type_to_string(mytype));
            $$ = new NullStatement;
        }else if($3->type() == ANIMATION_BLOCK && mytype != $3->type()){
            Error::error(Error::ANIMATION_BLOCK_ASSIGNMENT_PARAMETER_TYPE_ERROR,
                gpl_type_to_string(mytype), gpl_type_to_string($3->type()));
            $$ = new NullStatement;
        }else if(mytype == ANIMATION_BLOCK && $3->type() == ANIMATION_CODE){
            Animation_code::used_blocklist.insert(dynamic_cast<const Variable*>($3)->get_name());
            $$ = new Assign($1, $3);
        }else{
            $$ = new Assign($1, $3);
        }
    }
    | variable T_PLUS_ASSIGN expression{
        Gpl_type mytype = $1->type();
        if(!(mytype & (INT|DOUBLE|STRING))) {
            Error::error(Error::INVALID_LHS_OF_PLUS_ASSIGNMENT,
                $1->get_name(), gpl_type_to_string(mytype)); 
            $$ = new NullStatement;
        }else if(mytype == DOUBLE && !($3->type() & (DOUBLE|INT))) {
            Error::error(Error::PLUS_ASSIGNMENT_TYPE_ERROR,
                gpl_type_to_string(mytype), gpl_type_to_string($3->type()));
            $$ = new NullStatement;
        }else if(mytype == STRING && !($3->type() & (DOUBLE|INT|STRING))) {
            Error::error(Error::PLUS_ASSIGNMENT_TYPE_ERROR, 
                gpl_type_to_string(mytype), gpl_type_to_string($3->type()));
        }else if(mytype == INT && mytype != $3->type()) {
            Error::error(Error::PLUS_ASSIGNMENT_TYPE_ERROR, gpl_type_to_string(mytype), gpl_type_to_string($3->type()));
            $$ = new NullStatement;
        }else{
            $$=new Assign($1, new Plus($1, $3));
        }
    }
    | variable T_MINUS_ASSIGN expression{
        Gpl_type mytype = $1->type();
        if(!(mytype & (INT|DOUBLE))) {
            Error::error(Error::INVALID_LHS_OF_MINUS_ASSIGNMENT, 
                $1->get_name(), gpl_type_to_string(mytype)); 
            $$ = new NullStatement;
        }else if(mytype == DOUBLE && !($3->type() & (DOUBLE|INT))) {
            Error::error(Error::MINUS_ASSIGNMENT_TYPE_ERROR, 
                gpl_type_to_string(mytype), gpl_type_to_string($3->type()));
            $$ = new NullStatement;
        }else if(mytype == STRING && !($3->type() & (DOUBLE|INT|STRING))) {
            Error::error(Error::MINUS_ASSIGNMENT_TYPE_ERROR, 
                gpl_type_to_string(mytype), gpl_type_to_string($3->type()));
            $$ = new NullStatement;
        }else if(mytype == INT && mytype != $3->type()) {
            Error::error(Error::MINUS_ASSIGNMENT_TYPE_ERROR, 
                gpl_type_to_string(mytype), gpl_type_to_string($3->type()));
            $$ = new NullStatement;
        }else{
            $$ = new Assign($1, new Minus($1, $3));
        }
    }
    | variable T_PLUS_PLUS{
        if($1->type() != INT){
            Error::error(Error::INVALID_LHS_OF_PLUS_PLUS, 
                $1->get_name(), gpl_type_to_string($1->type())); 
            $$ = new NullStatement;
        }else{
            $$ = new Assign($1, new Plus($1, new Integer_constant(1)));
        }
    }
    | variable T_MINUS_MINUS{
        if($1->type() != INT) {
            Error::error(Error::INVALID_LHS_OF_MINUS_MINUS,
                $1->get_name(), gpl_type_to_string($1->type()));
            $$ = new NullStatement;
        }else{
            $$=new Assign($1, new Minus($1, new Integer_constant(1)));
        }
    }
    ;

//---------------------------------------------------------------------
variable:
    T_ID{
        Table_handler& mytable = Table_handler::instance();
        auto mysymb = mytable.lookup(*$1);
        //auto mysymb = Table_handler::instance().lookup(*$1);
        if(!mysymb){
            Error::error(Error::UNDECLARED_VARIABLE, *$1);
            delete $1;
            $$ = new Variable("");
        }else if(mysymb->get_count() > 0){
            Error::error(Error::VARIABLE_IS_AN_ARRAY, *$1);
            delete $1;
            $$ = new Variable("");
        }else{
            $$ = new Variable(*$1);
            delete $1;
        } 
    }
    | T_ID T_LBRACKET expression T_RBRACKET{
        Table_handler& mytable = Table_handler::instance();
        auto mysymb = mytable.lookup(*$1);
        if(!mysymb){
            Error::error(Error::UNDECLARED_VARIABLE, *$1+"[]");
            delete $1;
            delete $3;
            $$ = new Variable("");
        }else if(!(mysymb->get_count() > 0)) {
            Error::error(Error::VARIABLE_NOT_AN_ARRAY, *$1);
            delete $1;
            delete $3;
            $$ = new Variable("");
        }else if($3->type() != INT) {
            Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, gpl_type_to_string($3->type()));
            delete $1;
            delete $3;
            $$ = new Variable("");
        }else if(dynamic_cast<Constant*>($3) && $3->evaluate()->as_int() >= mysymb->get_count()) {
			Error::error(Error::ARRAY_INDEX_OUT_OF_BOUNDS, *$1, std::to_string($3->evaluate()->as_int()));
            delete $1;
            delete $3;
            $$ = new Variable("");
		}else{
            $$ = new Variable(*$1, $3);
            delete $1;
        }
    }
    | T_ID T_PERIOD T_ID {
        Table_handler& mytable = Table_handler::instance();
        auto mysymb = mytable.lookup(*$1);
        if(mysymb == nullptr){
            Error::error(Error::UNDECLARED_VARIABLE, *$1);
            $$ = new Variable("");
        }else if( mysymb->get_count() > 0){
            Error::error(Error::VARIABLE_IS_AN_ARRAY, *$1);
            $$ = new Variable("");
        }else{
            try{
                std::shared_ptr<const Constant>(mysymb->as_constant(*$3));
            }catch(Gpl_type err){
                Error::error(Error::LHS_OF_PERIOD_MUST_BE_OBJECT, *$1);
                $$ = new Variable("");
                break;
            }catch(std::out_of_range& err){
                Error::error(Error::UNDECLARED_MEMBER, *$1, *$3);
                $$ = new Variable("");
                break;
            }
            $$ = new Member_variable(*$1, *$3);
            delete $1;
            delete $3;
        }
    } 
    | T_ID T_LBRACKET expression T_RBRACKET T_PERIOD T_ID {
        Table_handler& mytable = Table_handler::instance();
        auto mysymb = mytable.lookup(*$1);
        if(mysymb == nullptr){
            Error::error(Error::UNDECLARED_VARIABLE, *$1+"[]");
            $$ = new Variable("");
        }else if(mysymb->get_count() < 1){
            Error::error(Error::VARIABLE_NOT_AN_ARRAY, *$1);
            $$ = new Variable("");
        }else if($3->type() != INT) {
            Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, gpl_type_to_string($3->type()), *$1);
            $$ = new Variable("");
            break;
        }else{
            try{
                std::shared_ptr<const Constant>(mysymb->as_constant(0, *$6));
            }catch(Gpl_type err){
                Error::error(Error::LHS_OF_PERIOD_MUST_BE_OBJECT, *$1);
                $$ = new Variable("");
                break;
            }catch(std::out_of_range& err){
                Error::error(Error::UNDECLARED_MEMBER, *$1, *$6);
                $$ = new Variable("");
                break;
            }
            $$ = new Member_variable(*$1, *$6, $3);
            delete $1;
            delete $6;
        }
    } 
    ;



//---------------------------------------------------------------------
expression:
    primary_expression                              {$$ = $1; /* $$ low key return value */ } 
    | expression T_OR expression                    {$$ = Bin_op_check <Or, OR> ($1, $3, INT|DOUBLE);}
    | expression T_AND expression                   {$$ = Bin_op_check <And, AND> ($1, $3, INT|DOUBLE);}
    | expression T_LESS_EQUAL expression            {$$ = Bin_op_check <Less_equal, LESS_EQUAL> ($1, $3, INT|DOUBLE|STRING);}
    | expression T_GREATER_EQUAL  expression        {$$ = Bin_op_check <Greater_equal, GREATER_EQUAL> ($1, $3, INT|DOUBLE|STRING);}
    | expression T_LESS expression                  {$$ = Bin_op_check <Less, LESS_THAN> ($1, $3, INT|DOUBLE|STRING);}
    | expression T_GREATER  expression              {$$ = Bin_op_check <Greater, GREATER_THAN> ($1, $3, INT|DOUBLE|STRING);}
    | expression T_EQUAL expression                 {$$ = Bin_op_check <Equal, EQUAL> ($1, $3, INT|DOUBLE|STRING);}
    | expression T_NOT_EQUAL expression             {$$ = Bin_op_check <Not_equal, NOT_EQUAL> ($1, $3, INT|DOUBLE|STRING);}
    | expression T_PLUS expression                  {$$ = Bin_op_check <Plus, PLUS> ($1,$3, INT|DOUBLE|STRING);}
    | expression T_MINUS expression                 {$$ = Bin_op_check <Minus, MINUS> ($1,$3, INT|DOUBLE);}
    | expression T_MULTIPLY expression              {$$ = Bin_op_check <Multiply, MULTIPLY> ($1, $3, INT|DOUBLE);}
    | expression T_NEAR expression                  {$$ = Bin_op_check<Near, NEAR>($1, $3, RECTANGLE|TRIANGLE|CIRCLE|TEXTBOX|PIXMAP);}
    | expression T_TOUCHES expression               {$$ = Bin_op_check<Touches, TOUCHES>($1, $3, RECTANGLE|TRIANGLE|CIRCLE|TEXTBOX|PIXMAP);}
    | expression T_DIVIDE expression                {$$ = Bin_op_check <Divide, DIVIDE> ($1, $3, INT|DOUBLE);}
    | expression T_MOD expression                   {$$ = Bin_op_check <Mod, MOD> ($1, $3, INT);}
    | T_MINUS  expression %prec UNARY_OPS           {$$ = Un_op_check <Unary_minus, UNARY_MINUS> ($2, INT|DOUBLE);}
    | T_NOT  expression                             {$$ = Un_op_check <Not, NOT> ($2, INT|DOUBLE);}
    | T_SIN T_LPAREN expression T_RPAREN            {$$ = Un_op_check <Sin, SIN> ($3, INT|DOUBLE);}
    | T_COS T_LPAREN expression T_RPAREN            {$$ = Un_op_check <Cos, COS> ($3, INT|DOUBLE);}
    | T_TAN T_LPAREN expression T_RPAREN            {$$ = Un_op_check <Tan, TAN> ($3, INT|DOUBLE);}
    | T_ASIN T_LPAREN expression T_RPAREN           {$$ = Un_op_check <Arcsin, ASIN> ($3, INT|DOUBLE);}
    | T_ACOS T_LPAREN expression T_RPAREN           {$$ = Un_op_check <Arccos, ACOS> ($3, INT|DOUBLE);}
    | T_ATAN T_LPAREN expression T_RPAREN           {$$ = Un_op_check <Arctan, ATAN> ($3, INT|DOUBLE);}
    | T_SQRT T_LPAREN expression T_RPAREN           {$$ = Un_op_check <Square_root, SQRT> ($3, INT|DOUBLE);}
    | T_ABS T_LPAREN expression T_RPAREN            {$$ = Un_op_check <Absolute_value, ABS> ($3, INT|DOUBLE);}
    | T_FLOOR T_LPAREN expression T_RPAREN          {$$ = Un_op_check <Floor, FLOOR> ($3, INT|DOUBLE);}
    | T_RANDOM T_LPAREN expression T_RPAREN         {$$ = Un_op_check <Random, RANDOM> ($3, INT|DOUBLE);}
    ;

//---------------------------------------------------------------------
primary_expression:
    T_LPAREN  expression T_RPAREN   {$$ = $2; /*TMP PROJ 3*/}
    | variable                      {$$ = $1; /*TMP PROJ 3*/}
    | T_INT_CONSTANT                {$$ = new Integer_constant($1);}
    | T_TRUE                        {$$ = new Integer_constant(1);}
    | T_FALSE                       {$$ = new Integer_constant(0);}
    | T_DOUBLE_CONSTANT             {$$ = new Double_constant($1);}
    | T_STRING_CONSTANT             {$$ = new String_constant(*$1);delete $1;}
    ;

//---------------------------------------------------------------------
empty:
    // empty goes to nothing so that you can use empty in productions
    // when you want a production to go to nothing
    ;

%%
